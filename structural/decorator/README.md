# 装饰器模式

一位素面朝天的女生可能会经过若干的步骤变的更加美艳动人。比如说经过抹口红、打粉底等。但是现实世界中各式各样的化妆品是多样的，女生可能会更希望通过自由组合来打造自己的美妆。为了解决该问题，装饰器模式考虑将这些各式各样的化妆品抽象为一个个装饰器，女生可以通过自由组合打造自己的专属美妆。

由于女生需求是多变且无法预估的，要实现不同功能的自由组合，以“继承”的方式来完成是不现实的，会造成子类泛滥，维护或扩展起来举步维艰。试想，用户可能需要“涂口红的女生”或“打粉底的女生”，也可能需要“打粉底再涂口红的女生”或“涂口红再打粉底的女生”。这 2 种化妆品就产生了女生类的 4 个子类，如果再增加些化妆品的话，罗列所有功能模块的排列组合会是一个不可能完成的任务。

装饰器模式（Decorator Pattern）可以将不同功能的单个模块规划至不同的装饰器类中，各装饰器类独立自主，各司其职。客户端可以根据自己的需求自由搭配各种装饰器，每加一层装饰就会有新的特性体现出来，巧妙的设计让功能模块层层叠加，装饰之上套装饰，最终使原始对象的特性动态地得到增强。

更通俗点说：装饰器模式就是做装饰，其目的是在不改变原有类型/功能/对象的情况下，对其进行装饰，扩展，以达到公共强化和扩展的目的。

装饰模式的目的是在原有功能或者能力的基础上提供额外的更多的能力和特性，这一点和代理模式、组合模式有很大不同的，了解每一种模式，重点是要了解这个模式的最初的设计者应用场景和其解决目的，以便加以利用。

装饰器模式包含下面的组件：

- Component（组件接口）：所有被装饰组件及装饰器对应的接口标准，指定进行装饰的行为方法。对应本章例程中的展示接口 Showable；
- ConcreteComponent（组件实现）：需要被装饰的组件，实现组件接口标准，只具备自身未被装饰的原始特性。对应本章例程中的女生类 Girl；
- Decorator（装饰器）：装饰器的高层抽象类，同样实现组件接口标准，且包含一个被装饰的组件；
- ConcreteDecorator（装饰器实现）：继承自装饰器抽象类的具体子类装饰器，可以有多种实现，在被装饰组件对象的基础上为其添加新的特性。对应本章例程中的粉底类 FoundationMakeup、口红类 Lipstick。

Go 语言借助于匿名组合和非入侵式接口可以很方便实现装饰模式。使用匿名组合，在装饰器中不必显式定义转调原对象方法。
